<h1 id="-">简介</h1>
<p>这篇指南的目的是教你如何书写高质量的TypeScript声明文件。
我们在这里会展示一些API的文档，还有它们的使用示例，
  并且阐述了如何为它们书写声明文件。</p>
<p>这些例子是按复杂度递增的顺序组织的。</p>
<ul>
<li><a href="#global-variables">全局变量</a></li>
<li><a href="#global-functions">全局函数</a></li>
<li><a href="#objects-with-properties">带属性的对象</a></li>
<li><a href="#overloaded-functions">函数重载</a></li>
<li><a href="#reusable-types-interfaces">可重用类型（接口）</a></li>
<li><a href="#reusable-types-type-aliases">可重用类型（类型别名）</a></li>
<li><a href="#organizing-types">组织类型</a></li>
<li><a href="#classes">类</a></li>
</ul>
<h1 id="-">例子</h1>
<h2 id="-a-name-global-variables-a-"><a name="global-variables"></a>全局变量</h2>
<p><em>文档</em></p>
<blockquote>
<p>全局变量<code>foo</code>包含了存在组件总数。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">console.log(&quot;Half the number of widgets is &quot; + (foo / 2));
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare var</code>声明变量。
如果变量是只读的，那么可以使用<code>declare const</code>。
你还可以使用<code>declare let</code>如果变量拥有块级作用域。</p>
<pre><code class="lang-ts">/** 组件总数 */
declare var foo: number;
</code></pre>
<h2 id="-a-name-global-functions-a-"><a name="global-functions"></a>全局函数</h2>
<p><em>文档</em></p>
<blockquote>
<p>用一个字符串参数调用<code>greet</code>函数向用户显示一条欢迎信息。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">greet(&quot;hello, world&quot;);
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare function</code>声明函数。</p>
<pre><code class="lang-ts">declare function greet(greeting: string): void;
</code></pre>
<h2 id="-a-name-objects-with-properties-a-"><a name="objects-with-properties"></a>带属性的对象</h2>
<p><em>文档</em></p>
<blockquote>
<p>全局变量<code>myLib</code>包含一个<code>makeGreeting</code>函数，
还有一个属性<code>numberOfGreetings</code>指示目前为止欢迎数量。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">let result = myLib.makeGreeting(&quot;hello, world&quot;);
console.log(&quot;The computed greeting is:&quot; + result);

let count = myLib.numberOfGreetings;
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare namespace</code>描述用点表示法访问的类型或值。</p>
<pre><code class="lang-ts">declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}
</code></pre>
<h2 id="-a-name-overloaded-functions-a-"><a name="overloaded-functions"></a>函数重载</h2>
<p><em>文档</em></p>
<blockquote>
<p><code>getWidget</code>函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">let x: Widget = getWidget(43);

let arr: Widget[] = getWidget(&quot;all of them&quot;);
</code></pre>
<p><em>声明</em></p>
<pre><code class="lang-ts">declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];
</code></pre>
<h2 id="-a-name-reusable-types-interfaces-a-"><a name="reusable-types-interfaces"></a>可重用类型（接口）</h2>
<p><em>文档</em></p>
<blockquote>
<p>当指定一个欢迎词时，你必须传入一个<code>GreetingSettings</code>对象。
这个对象具有以下几个属性：</p>
<p>1- greeting：必需的字符串
2- duration: 可靠的时长（毫秒表示）
3- color: 可选字符串，比如‘#ff00ff’</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">greet({
  greeting: &quot;hello world&quot;,
  duration: 4000
});
</code></pre>
<p><em>声明</em></p>
<p>使用<code>interface</code>定义一个带有属性的类型。</p>
<pre><code class="lang-ts">interface GreetingSettings {
  greeting: string;
  duration?: number;
  color?: string;
}

declare function greet(setting: GreetingSettings): void;
</code></pre>
<h2 id="-a-name-reusable-types-type-aliases-a-"><a name="reusable-types-type-aliases"></a>可重用类型（类型别名）</h2>
<p><em>文档</em></p>
<blockquote>
<p>在任何需要欢迎词的地方，你可以提供一个<code>string</code>，一个返回<code>string</code>的函数或一个<code>Greeter</code>实例。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">function getGreeting() {
    return &quot;howdy&quot;;
}
class MyGreeter extends Greeter { }

greet(&quot;hello&quot;);
greet(getGreeting);
greet(new MyGreeter());
</code></pre>
<p><em>声明</em></p>
<p>你可以使用类型别名来定义类型的短名：</p>
<pre><code class="lang-ts">type GreetingLike = string | (() =&gt; string) | MyGreeter;

declare function greet(g: GreetingLike): void;
</code></pre>
<h2 id="-a-name-organizing-types-a-"><a name="organizing-types"></a>组织类型</h2>
<p><em>文档</em></p>
<blockquote>
<p><code>greeter</code>对象能够记录到文件或显示一个警告。
你可以为<code>.log(...)</code>提供LogOptions和为<code>.alert(...)</code>提供选项。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">const g = new Greeter(&quot;Hello&quot;);
g.log({ verbose: true });
g.alert({ modal: false, title: &quot;Current Greeting&quot; });
</code></pre>
<p><em>声明</em></p>
<p>使用命名空间组织类型。</p>
<pre><code class="lang-ts">declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<p>你也可以在一个声明中创建嵌套的命名空间：</p>
<pre><code class="lang-ts">declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}
</code></pre>
<h2 id="-a-name-classes-a-"><a name="classes"></a>类</h2>
<p><em>文档</em></p>
<blockquote>
<p>你可以通过实例化<code>Greeter</code>对象来创建欢迎词，或者继承<code>Greeter</code>对象来自定义欢迎词。</p>
</blockquote>
<p><em>代码</em></p>
<pre><code class="lang-ts">const myGreeter = new Greeter(&quot;hello, world&quot;);
myGreeter.greeting = &quot;howdy&quot;;
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super(&quot;Very special greetings&quot;);
    }
}
</code></pre>
<p><em>声明</em></p>
<p>使用<code>declare class</code>描述一个类或像类一样的对象。
类可以有属性和方法，就和构造函数一样。</p>
<pre><code class="lang-ts">declare class Greeter {
    constructor(greeting: string);

    greeting: string;
    showGreeting(): void;
}
</code></pre>
<!-- Template

##

*Documentation*
>

*Code*

```ts

```

*Declaration*

```ts

```

-->
